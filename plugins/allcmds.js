const crypto = require('crypto');
const axios = require('axios');
const { cmd, commands } = require('../command');
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const config = require('../config');
const { igdl } = require('ruhend-scraper');

cmd({
    pattern: "gpass",
    desc: "Generate a strong password.",
    category: "other",
    react: "ğŸ”",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const length = args[0] ? parseInt(args[0]) : 12; // Default length is 12 if not provided
        if (isNaN(length) || length < 8) {
            return reply('Please provide a valid length for the password (minimum 8 characters).');
        }

        const generatePassword = (len) => {
            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+[]{}|;:,.<>?';
            let password = '';
            for (let i = 0; i < len; i++) {
                const randomIndex = crypto.randomInt(0, charset.length);
                password += charset[randomIndex];
            }
            return password;
        };

        const password = generatePassword(length);
        const message = `ğŸ” *Your Strong Password* ğŸ”\n\nPlease find your generated password below:\n\n> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*`;

        // Send initial notification message
        await conn.sendMessage(from, { text: message }, { quoted: mek });

        // Send the password in a separate message
        await conn.sendMessage(from, { text: password }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`âŒ Error generating password: ${e.message}`);
    }
});

cmd({
    pattern: "srepo",
    desc: "Fetch information about a GitHub repository.",
    category: "other",
    react: "ğŸ“",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const repo = args.join(' ');
        if (!repo) {
            return reply("Please provide a GitHub repository name in the format `owner/repo`.");
        }

        const apiUrl = `https://api.github.com/repos/${repo}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let repoInfo = `ğŸ“_*GitHub Repository Info*_ğŸ“\n\n`;
        repoInfo += `ğŸ“Œ *Name*: ${data.name}\n`;
        repoInfo += `ğŸ”— *URL*: ${data.html_url}\n`;
        repoInfo += `ğŸ“ *Description*: ${data.description}\n`;
        repoInfo += `â­ *Stars*: ${data.stargazers_count}\n`;
        repoInfo += `ğŸ´ *Forks*: ${data.forks_count}\n`;
        repoInfo += `\n`;
        repoInfo += `> KENZI-MD\n`;

        await conn.sendMessage(from, { text: repoInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching repository info: ${e.message}`);
    }
});

cmd({
    pattern: "weather",
    desc: "ğŸŒ¤ Get weather information for a location",
    react: "ğŸŒ¤",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("â— Please provide a city name. Usage: .weather [city name]");

        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;

        const response = await axios.get(url);
        const data = response.data;

        const weather = `
ğŸŒ *Weather Information for ${data.name}, ${data.sys.country}* ğŸŒ

ğŸŒ¡ï¸ *Temperature*: ${data.main.temp}Â°C
ğŸŒ¡ï¸ *Feels Like*: ${data.main.feels_like}Â°C
ğŸŒ¡ï¸ *Min Temp*: ${data.main.temp_min}Â°C
ğŸŒ¡ï¸ *Max Temp*: ${data.main.temp_max}Â°C
ğŸ’§ *Humidity*: ${data.main.humidity}%
â˜ï¸ *Weather*: ${data.weather[0].main}
ğŸŒ«ï¸ *Description*: ${data.weather[0].description}
ğŸ’¨ *Wind Speed*: ${data.wind.speed} m/s
ğŸ”½ *Pressure*: ${data.main.pressure} hPa

> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤* ğŸŒ¦ï¸
`;

        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("ğŸš« City not found. Please check the spelling and try again.");
        }
        return reply("âš ï¸ An error occurred while fetching the weather information. Please try again later.");
    }
});

cmd({
    pattern: "githubstalk",
    desc: "Fetch detailed GitHub user profile including profile picture.",
    category: "other",
    react: "ğŸ–¥ï¸",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const username = args[0];
        if (!username) {
            return reply("Please provide a GitHub username.");
        }

        const apiUrl = `https://api.github.com/users/${username}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        let userInfo = `     ğŸ”_*KENZI-MD GIT STALK*_ğŸ”
        
ğŸ‘¤ *Username*: ${data.name || data.login}
ğŸ”— *Github Url*:(${data.html_url})
ğŸ“ *Bio*: ${data.bio || 'Not available'}
ğŸ™ï¸ *Location*: ${data.location || 'Unknown'}
ğŸ“Š *Public Repos*: ${data.public_repos}
ğŸ‘¥ *Followers*: ${data.followers} | Following: ${data.following}
ğŸ“… *Created At*: ${new Date(data.created_at).toDateString()}
ğŸ”­ *Public Gists*: ${data.public_gists}

> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*
`;

        await conn.sendMessage(from, { image: { url: data.avatar_url }, caption: userInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching data: ${e.response ? e.response.data.message : e.message}`);
    }
});

cmd({
    pattern: "about",
    desc: "To get the bot informations.",
    react: "â„¹ï¸",
    category: "main",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

let about = ` HELLOW THEIR ${senderNumber} I AM QUEEN_ROSHIKA WHATSAPP BOT 
              CREATED BY KENZI-MD(DÎ›Ğ¯K ĞŸÎ£Ó¨ĞŸ á‘•YBÎ£Ğ¯Z)..
              
              > *Â© ï¼¤ï½ï½’ï½‹ ï¼®ï½…ï½ï½ ï¼£ï½™ï½‚ï½…ï½’ï½š*
              > *É¢Éªá´›Êœá´œÊ™ :* github.com/Danupa0
              
              THANKS FOR USING KENZI-MD WHATSAPP BOT MD`
return await conn.sendMessage(from,{image: {url: config.ALIVE_IMG},caption:about},{quoted: mek})
}catch(e){
console.log(e)
reply(`${e}`)
}
})

cmd({
    pattern: "ig",
    desc: "To download instagram videos.",
    category: "download",
    filename: __filename
},
async(conn, mek, m,{from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{

  if (!args[0]) {
    return reply('*`Please give a waild Instagram link`*');
  }

  await m.react('ğŸ•’');
  let res;
  try {
    res = await igdl(args[0]);
  } catch (error) {
    return reply('*`Error obtaining data.`*');
  }

  let result = res.data;
  if (!result || result.length === 0) {
    return reply('*`No result found.`*');
  }

  let data;
  try {
    data = result.find(i => i.resolution === "720p (HD)") || result.find(i => i.resolution === "360p (SD)");
  } catch (error) {
    return reply('*`Error data loss.`*');
  }

  if (!data) {
    return reply('*`No data found.`*');
  }

  await m.react('âœ…');
  let video = data.url;
  let dev = 'Â© 2024 KENZI-MD Instagram Downloader | Download with ease, cherish forever.'
  
  try {
    await conn.sendMessage(m.chat, { video: { url: video }, caption: dev, fileName: 'ig.mp4', mimetype: 'video/mp4' }, { quoted: m });
  } catch (error) {
    return reply('*`Error download video.`*');
  await m.react('âŒ');
  }
}catch(e){
console.log(e)
  reply(`${e}`)
}
});

cmd({
    pattern: "news",
    desc: "Get the latest news headlines.",
    category: "other",
    react: "ğŸ“°",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const apiKey="0f2c43ab11324578a7b1709651736382";
        const response = await axios.get(`https://newsapi.org/v2/top-headlines?country=us&apiKey=${apiKey}`);
        const articles = response.data.articles;

        if (!articles.length) return reply("No news articles found.");

        // Send each article as a separate message with image and title
        for (let i = 0; i < Math.min(articles.length, 5); i++) {
            const article = articles[i];
            let message = `
ğŸ“° *${article.title}*
âš ï¸ _${article.description}_
ğŸ”— _${article.url}_

*Â© ï¼¤ï½ï½’ï½‹ ï¼®ï½…ï½ï½ ï¼£ï½™ï½‚ï½…ï½’ï½š ğŸ…¥* 
*ğŸ’» BOT NAME:* ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤  
            `;

            console.log('Article URL:', article.urlToImage); // Log image URL for debugging

            if (article.urlToImage) {
                // Send image with caption
                await conn.sendMessage(from, { image: { url: article.urlToImage }, caption: message });
            } else {
                // Send text message if no image is available
                await conn.sendMessage(from, { text: message });
            }
        };
    } catch (e) {
        console.error("Error fetching news:", e);
        reply("Could not fetch news. Please try again later.");
    }
});

cmd({
    pattern: "trt",
    desc: "ğŸŒ Translate text between languages",
    react: "ğŸŒ",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const args = q.split(' ');
        if (args.length < 2) return reply("â— Please provide a language code and text. Usage: .translate [language code] [text]");

        const targetLang = args[0];
        const textToTranslate = args.slice(1).join(' ');

        const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(textToTranslate)}&langpair=en|${targetLang}`;

        const response = await axios.get(url);
        const translation = response.data.responseData.translatedText;

        const translationMessage = `
ğŸŒ *Translation* ğŸŒ

ğŸ”¤ *Original*: ${textToTranslate}
ğŸ”  *Translated*: ${translation}
ğŸŒ *Language*: ${targetLang.toUpperCase()}

> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*`;

        return reply(translationMessage);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ An error occurred while translating the text. Please try again later.");
    }
});

cmd({
    pattern: "fact",
    desc: "ğŸ§  Get a random fun fact",
    react: "ğŸ¤“",
    category: "fun",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://uselessfacts.jsph.pl/random.json?language=en';  // API for random facts
        const response = await axios.get(url);
        const fact = response.data.text;

        const funFact = `
ğŸ§  *Random Fun Fact* ğŸ§ 

${fact}

Isn't that interesting? ğŸ˜„
`;

        return reply(funFact);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ An error occurred while fetching a fun fact. Please try again later.");
    }
});


cmd({
    pattern: "dog",
    desc: "Fetch a random dog image.",
    category: "fun",
    react: "ğŸ¶",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://dog.ceo/api/breeds/image/random`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.message }, caption: 'ğŸ¶ *Random Dog Image* ğŸ¶\n> *âš–ï¸ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching dog image: ${e.message}`);
    }
});

cmd({
    pattern: "rvideo",
    desc: "Fetch and send a random video from Pexels.",
    category: "fun",
    react: "ğŸ¥",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        // Notify user that the video is being downloaded
        await conn.sendMessage(from, { text: '> â³ *Waiting, your video is downloading...* â³' }, { quoted: mek });

        const apiUrl = `https://api.pexels.com/videos/search?query=random&per_page=1&page=${Math.floor(Math.random() * 100) + 1}`;
        const response = await axios.get(apiUrl, { headers: { Authorization: config.PEXELS_API_KEY } });

        const video = response.data.videos[0];
        if (!video || !video.video_files || video.video_files.length === 0) {
            throw new Error('No video files found in the response');
        }

        const videoUrl = video.video_files[0].link;
        const videoTitle = video.title || 'Random Video';

        // Download the video
        const videoPath = path.join(__dirname, 'tempVideo.mp4');
        const writer = fs.createWriteStream(videoPath);

        const responseVideo = await axios.get(videoUrl, { responseType: 'stream' });
        responseVideo.data.pipe(writer);

        writer.on('finish', async () => {
            await conn.sendMessage(from, { text: 'âœ… *Your video has been successfully downloaded!* âœ…' }, { quoted: mek });
            await conn.sendMessage(from, { video: { url: videoPath }, caption: `ğŸ¥ *Random Pexels Video* ğŸ¥\n\nTitle: ${videoTitle}\n> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*` }, { quoted: mek });

            // Clean up
            fs.unlinkSync(videoPath);
        });

        writer.on('error', (err) => {
            console.log(err);
            reply(`âŒ Error downloading video: ${err.message}`);
        });
    } catch (e) {
        console.log(e);
        reply(`âŒ Error fetching video: ${e.message}`);
    }
});

cmd({
    pattern: "quote",
    desc: "Get a random inspiring quote.",
    category: "fun",
    react: "ğŸ’¬",
    filename: __filename
},
async (conn, mek, m, { from, reply }) => {
    try {
        const response = await axios.get('https://api.quotable.io/random');
        const quote = response.data;
        const message = `
ğŸ’¬ "${quote.content}"
- ${quote.author}
*ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤* QUOTES
        `;
        return reply(message);
    } catch (e) {
        console.error("Error fetching quote:", e);
        reply("Could not fetch a quote. Please try again later.");
    }
});

cmd({
    pattern: "animegirl",
    desc: "Fetch a random anime girl image.",
    category: "fun",
    react: "ğŸ‘§",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const apiUrl = `https://api.waifu.pics/sfw/waifu`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        await conn.sendMessage(from, { image: { url: data.url }, caption: 'ğŸ‘§ *Random Anime Girl Image* ğŸ‘§\n> *ğŸ”®ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*' }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching anime girl image: ${e.message}`);
    }
});

cmd({
    pattern: "movie",
    desc: "Fetch detailed information about a movie.",
    category: "other",
    react: "ğŸ¬",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const movieName = args.join(' ');
        if (!movieName) {
            return reply("ğŸ“½ï¸ Please provide the name of the movie.");
        }

        const apiUrl = `http://www.omdbapi.com/?t=${encodeURIComponent(movieName)}&apikey=${config.OMDB_API_KEY}`;
        const response = await axios.get(apiUrl);

        const data = response.data;
        if (data.Response === "False") {
            return reply("ğŸš« Movie not found.");
        }

        const movieInfo = `
ğŸ”® *MOVIE INFORMATION* ğŸ”®

ğŸ¥ *Title:* ${data.Title}
ğŸ“… *Year:* ${data.Year}
ğŸŒŸ *Rated:* ${data.Rated}
ğŸ“† *Released:* ${data.Released}
â³ *Runtime:* ${data.Runtime}
ğŸ­ *Genre:* ${data.Genre}
ğŸ¬ *Director:* ${data.Director}
âœï¸ *Writer:* ${data.Writer}
ğŸ­ *Actors:* ${data.Actors}
ğŸ“ *Plot:* ${data.Plot}
ğŸŒ *Language:* ${data.Language}
ğŸ‡ºğŸ‡¸ *Country:* ${data.Country}
ğŸ† *Awards:* ${data.Awards}
â­ *IMDB Rating:* ${data.imdbRating}
ğŸ—³ï¸ *IMDB Votes:* ${data.imdbVotes}
`;

        // Define the image URL
        const imageUrl = data.Poster && data.Poster !== 'N/A' ? data.Poster : config.ALIVE_IMG;

        // Send the movie information along with the poster image
        await conn.sendMessage(from, {
            image: { url: imageUrl },
            caption: `${movieInfo}\n> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*`
        }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`âŒ Error: ${e.message}`);
    }
});

// 1. Shutdown Bot
cmd({
    pattern: "shutdown",
    desc: "Shutdown the bot.",
    category: "owner",
    react: "ğŸ›‘",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    reply("ğŸ›‘ Shutting down...").then(() => process.exit());
});

// 2. Broadcast Message to All Groups
cmd({
    pattern: "broadcast",
    desc: "Broadcast a message to all groups.",
    category: "owner",
    react: "ğŸ“¢",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, args, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (args.length === 0) return reply("ğŸ“¢ Please provide a message to broadcast.");

    const message = args.join(' ');
    const groups = Object.keys(await conn.groupFetchAllParticipating());

    for (const groupId of groups) {
        await conn.sendMessage(groupId, { text: message }, { quoted: mek });
    }

    reply("ğŸ“¢ Message broadcasted to all groups.");
});

// 3. Set Profile Picture
cmd({
    pattern: "setpp",
    desc: "Set bot profile picture.",
    category: "owner",
    react: "ğŸ–¼ï¸",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted || !quoted.message.imageMessage) return reply("âŒ Please reply to an image.");

    try {
        const media = await conn.downloadMediaMessage(quoted);
        await conn.updateProfilePicture(conn.user.jid, { url: media });
        reply("ğŸ–¼ï¸ Profile picture updated successfully!");
    } catch (error) {
        reply(`âŒ Error updating profile picture: ${error.message}`);
    }
});

// 4. Block User
cmd({
    pattern: "block",
    desc: "Block a user.",
    category: "owner",
    react: "ğŸš«",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted) return reply("âŒ Please reply to the user you want to block.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'block');
        reply(`ğŸš« User ${user} blocked successfully.`);
    } catch (error) {
        reply(`âŒ Error blocking user: ${error.message}`);
    }
});

// 5. Unblock User
cmd({
    pattern: "unblock",
    desc: "Unblock a user.",
    category: "owner",
    react: "âœ…",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    if (!quoted) return reply("âŒ Please reply to the user you want to unblock.");

    const user = quoted.sender;
    try {
        await conn.updateBlockStatus(user, 'unblock');
        reply(`âœ… User ${user} unblocked successfully.`);
    } catch (error) {
        reply(`âŒ Error unblocking user: ${error.message}`);
    }
});

// 6. Clear All Chats
cmd({
    pattern: "clearchats",
    desc: "Clear all chats from the bot.",
    category: "owner",
    react: "ğŸ§¹",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    try {
        const chats = conn.chats.all();
        for (const chat of chats) {
            await conn.modifyChat(chat.jid, 'delete');
        }
        reply("ğŸ§¹ All chats cleared successfully!");
    } catch (error) {
        reply(`âŒ Error clearing chats: ${error.message}`);
    }
});

// 7. Get Bot JID
cmd({
    pattern: "jid",
    desc: "Get the bot's JID.",
    category: "owner",
    react: "ğŸ¤–",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");
    reply(`ğŸ¤– *Bot JID:* ${conn.user.jid}`);
});

// 8. Group JIDs List
cmd({
    pattern: "gjid",
    desc: "Get the list of JIDs for all groups the bot is part of.",
    category: "owner",
    react: "ğŸ“",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("âŒ You are not the owner!");

    const groups = await conn.groupFetchAllParticipating();
    const groupJids = Object.keys(groups).join('\n');
    reply(`ğŸ“ *Group JIDs:*\n\n${groupJids}`);
});

cmd({
    pattern: "convert",
    desc: "Convert an amount from one currency to another.",
    category: "convert",
    react: "ğŸ’±",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (args.length < 3) {
            return reply("Usage: .convert <amount> <from_currency> <to_currency>");
        }

        const amount = args[0];
        const fromCurrency = args[1].toUpperCase();
        const toCurrency = args[2].toUpperCase();

        if (isNaN(amount)) {
            return reply("Please provide a valid amount.");
        }

        const apiUrl = `https://api.exchangerate-api.com/v4/latest/${fromCurrency}`;
        const response = await axios.get(apiUrl);
        const data = response.data;

        if (!data.rates[toCurrency]) {
            return reply(`Conversion rate for ${toCurrency} not found.`);
        }

        const convertedAmount = (amount * data.rates[toCurrency]).toFixed(2);
        let conversionInfo = `ğŸ’¸_*Currency Conversion*_ğŸ’¸\n\n`;
        conversionInfo += `ğŸ’µ *Amount*: ${amount} ${fromCurrency}\n`;
        conversionInfo += `ğŸ”„ *Converted Amount*: ${convertedAmount} ${toCurrency}\n`;
        conversionInfo += `ğŸ“ˆ *Exchange Rate*: 1 ${fromCurrency} = ${data.rates[toCurrency]} ${toCurrency}\n
        
> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*
        `;

        await conn.sendMessage(from, { text: conversionInfo }, { quoted: mek });
    } catch (e) {
        console.log(e);
        reply(`Error fetching data: ${e.message}`);
    }
});

cmd({
    pattern: "hack",
    desc: "Displays a dynamic and playful 'Hacking' message for fun.",
    category: "fun",
    react: "ğŸ’»",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        const steps = [
            'ğŸ’» *HACK STARTING...* ğŸ’»',
            '',
            '*Initializing hacking tools...* ğŸ› ï¸',
            '*Connecting to remote servers...* ğŸŒ',
            '',
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 10%``` â³'                                            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 20%``` â³'                                   ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 30%``` â³'                               ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 40%``` â³'                            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 50%``` â³'                       ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 60%``` â³'                 ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 70%``` â³'            ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 80%``` â³'        ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 90%``` â³'    ,
            '```[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%``` âœ…',
            '',
            'ğŸ”’ *System Breach: Successful!* ğŸ”“',
            'ğŸš€ *Command Execution: Complete!* ğŸ¯',
            '',
            '*ğŸ“¡ Transmitting data...* ğŸ“¤',
            '_ğŸ•µï¸â€â™‚ï¸ Ensuring stealth..._ ğŸ¤«',
            '*ğŸ”§ Finalizing operations...* ğŸ',
            '',
            'âš ï¸ *Note:* All actions are for demonstration purposes only.',
            'âš ï¸ *Reminder:* Ethical hacking is the only way to ensure security.',
            '',
            '> *KENZI-MD-HACKING-COMPLETE â˜ ï¸â•*'
        ];

        for (const line of steps) {
            await conn.sendMessage(from, { text: line }, { quoted: mek });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Adjust the delay as needed
        }
    } catch (e) {
        console.log(e);
        reply(`âŒ *Error:* ${e.message}`);
    }
});

cmd({
    pattern: "joke",
    desc: "ğŸ˜‚ Get a random joke",
    react: "ğŸ¤£",
    category: "fun",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        const url = 'https://official-joke-api.appspot.com/random_joke';  // API for random jokes
        const response = await axios.get(url);
        const joke = response.data;

        const jokeMessage = `
ğŸ˜‚ *Here's a random joke for you!* ğŸ˜‚

*${joke.setup}*

${joke.punchline} ğŸ˜„

*Â© ï¼¤ï½ï½’ï½‹ ï¼®ï½…ï½ï½ ï¼£ï½™ï½‚ï½…ï½’ï½š* 
*ğŸ’» GitHub:* github.com/Danupa0 `;

        return reply(jokeMessage);
    } catch (e) {
        console.log(e);
        return reply("âš ï¸ Couldn't fetch a joke right now. Please try again later.");
    }
});

cmd({
                             pattern: "define",
                             desc: "ğŸ“š Get the definition of a word",
                             react: "ğŸ”",
                             category: "other",
                             filename: __filename
                         },
                         async (conn, mek, m, { from, q, reply }) => {
                             try {
                                 if (!q) return reply("â— Please provide a word to define. Usage: .define [word]");

                                 const word = q;
                                 const url = `https://api.dictionaryapi.dev/api/v2/entries/en/${word}`;

                                 const response = await axios.get(url);
                                 const definitionData = response.data[0];

                                 const definition = definitionData.meanings[0].definitions[0].definition;
                                 const example = definitionData.meanings[0].definitions[0].example || 'No example available';
                                 const synonyms = definitionData.meanings[0].definitions[0].synonyms.join(', ') || 'No synonyms available';

const wordInfo = `
ğŸ“š *Word*: ${definitionData.word}
ğŸ” *Definition*: ${definition}
ğŸ“ *Example*: ${example}
ğŸ”— *Synonyms*: ${synonyms}

> *ğŸ”® ğğ¨ğ°ğğ«ğğ ğğ² - : ğŸ’ƒğğ”ğ„ğ„ğ ğŠğ„ğğ™ğˆ ğŒğƒ ğŸ¤*`;

                                 return reply(wordInfo);
                             } catch (e) {
                                 console.log(e);
                                 if (e.response && e.response.status === 404) {
                                     return reply("ğŸš« Word not found. Please check the spelling and try again.");
                                 }
                                 return reply("âš ï¸ An error occurred while fetching the definition. Please try again later.");
                             }
                         });
